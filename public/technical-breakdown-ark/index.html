<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- GENERAL -->
  <title>Zeljko Vranjes - Blog</title>
  <!-- FONTS -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
    rel="stylesheet" />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
    rel="stylesheet" />
  <!-- STYLESHEETS -->
  
  <link rel="stylesheet" href="https://blog.zeljkovranjes.com/main.css" />
  
  <link rel="stylesheet" href="https://blog.zeljkovranjes.com/modern-normalize.css" />
  
  <!--
  <meta
    http-equiv="Content-Security-Policy"
    content="default-src 'self' ws://127.0.0.1:1024/; img-src 'self' https://*; script-src 'self'; style-src 'self'; font-src 'self'" />
--></head>

  <body>
    <main>
<div class="content">
  <div class="col" style="gap: 7px">
    <div
      class="column"
      style="font-size: 0.85rem; justify-content: center; gap: 25px">
      <a href="/" style="text-decoration: none">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          fill="currentColor"
          class="bi bi-arrow-90deg-left"
          viewBox="0 0 16 16">
          <path
            fill-rule="evenodd"
            d="M1.146 4.854a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 4H12.5A2.5 2.5 0 0 1 15 6.5v8a.5.5 0 0 1-1 0v-8A1.5 1.5 0 0 0 12.5 5H2.707l3.147 3.146a.5.5 0 1 1-.708.708z" />
        </svg>
        BLOG
      </a>
      <div class="header">
        <div class="title">Technical Breakdown: Ark</div>
        <div class="date">December, 25, 2023</div>
      </div>
      <div class="links">
        <a
          href="https://github.com/chomnr/blog/tree/main/content/technical-breakdown-ark.md">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            fill="currentColor"
            class="bi bi-code"
            viewBox="0 0 16 16">
            <path
              d="M5.854 4.854a.5.5 0 1 0-.708-.708l-3.5 3.5a.5.5 0 0 0 0 .708l3.5 3.5a.5.5 0 0 0 .708-.708L2.707 8zm4.292 0a.5.5 0 0 1 .708-.708l3.5 3.5a.5.5 0 0 1 0 .708l-3.5 3.5a.5.5 0 0 1-.708-.708L13.293 8z" />
          </svg>
        </a>
      </div>
    </div>
  </div>
</div>
<div class="post-content"><h1 id="what-is-ark">What is Ark?</h1>
<p><a href="https://github.com/notpointless/ark"><strong>notpointless/ark</strong></a> is a full-stack monolithic application with a robust Identity and Access Management (IAM) solution at its core. Initially developed as a closed-source component for a side project, I've since decided to release it to the public.</p>
<h2 id="technical-breakdown">Technical Breakdown</h2>
<p>Below, I'll walk through my thought process and reasoning behind key design decisions during the development of this project. For each component, I'll detail the advantages, disadvantages, and potential alternative approaches.</p>
<h3 id="task-system">Task System</h3>
<p>The Task System was designed to streamline database operations. Rather than repeatedly reinstantiating database connections to update fields, we can <em>queue</em> desired tasks through a specialized system. This approach significantly improves function clarity and execution efficiency.</p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe7391452-e63c-4bf5-995b-1c62aa48c8aa_676x316.png" alt="Task System Architecture" /></p>
<p>Consider the difference between traditional database operations and the Task System approach:</p>
<p><strong>Traditional approach:</strong></p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">create_permission</span><span>(</span><span style="color:#bf616a;">database</span><span>: PostgresDatabase, </span><span style="color:#bf616a;">permission</span><span>: Permission) -&gt; Result&lt;T&gt; {
</span><span>    </span><span style="color:#65737e;">/* perform operation here */
</span><span>}
</span></code></pre>
<p><strong>Task System approach:</strong></p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">create_permission</span><span>(</span><span style="color:#bf616a;">permission</span><span>: Permission) -&gt; TaskResult&lt;T&gt; {
</span><span>    </span><span style="color:#65737e;">/* queue message here */
</span><span>}
</span></code></pre>
<p>Instead of direct instantiation through a CRUD function, the Task System handles the instantiation when it receives the task.</p>
<h4 id="task-system-components">Task System Components</h4>
<p>To successfully compose and send a task to the Task System, you need three essential components:</p>
<ol>
<li><a href="https://github.com/notpointless/ark/blob/afcea9414389ddc29ce34fa782ac4e96fb990cc3/src/app/service/task/message.rs#L27"><strong>TaskType</strong></a> - Identifies which handler to use</li>
<li><a href="https://github.com/notpointless/ark/blob/afcea9414389ddc29ce34fa782ac4e96fb990cc3/src/app/platform/iam/role/task.rs#L22"><strong>TaskHandler&lt;D&gt;</strong></a> - Assigns a specific "action" to Task&lt;D, R, P&gt;
<ul>
<li>D: Database</li>
</ul>
</li>
<li><a href="https://github.com/notpointless/ark/blob/afcea9414389ddc29ce34fa782ac4e96fb990cc3/src/app/platform/iam/role/task.rs#L189"><strong>Task&lt;D, R, P&gt;</strong></a> - Performs the actual task
<ul>
<li>D: Database</li>
<li>R: TaskRequest</li>
<li>P: The Type</li>
</ul>
</li>
</ol>
<p>Once these components are defined, you must register the TaskType with the corresponding listener. You can see how to register a listener <a href="https://github.com/notpointless/ark/blob/afcea9414389ddc29ce34fa782ac4e96fb990cc3/src/app/service/task/manager.rs#L174">here</a>.</p>
<p>With registration complete, you can create a function that sends requests to the task channel:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">create_role</span><span>(</span><span style="color:#bf616a;">role</span><span>: Role) -&gt; TaskResult&lt;TaskStatus&gt; {
</span><span>    </span><span style="color:#b48ead;">let</span><span> task_request = </span><span style="color:#b48ead;">Self</span><span>::create_role_request(role);
</span><span>    TaskManager::process_task(task_request)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">create_role_request</span><span>(</span><span style="color:#bf616a;">role</span><span>: Role) -&gt; TaskRequest {
</span><span>    TaskRequest::compose_request(RoleCreateTask::from(role), TaskType::Role, &quot;</span><span style="color:#a3be8c;">role_create</span><span>&quot;)
</span><span>}
</span></code></pre>
<p><code>TaskRequest</code> composes a request that the Task System can interpret. Then, calling <code>TaskManager::process_task(task_request)</code> will return either a Completed or Failed status. If you expect a custom return type, you can use <code>TaskManager::process_task_with_result::&lt;T&gt;(request)</code> instead.</p>
<h4 id="channeling">Channeling</h4>
<p>The Task System uses a bidirectional channel flow. When the system receives a request, it first routes to the INBOUND channel, then sends results to the OUTBOUND channel. This bidirectional setup enables reliable result retrieval.</p>
<h4 id="advantages-and-disadvantages">Advantages and Disadvantages</h4>
<p><strong>Advantages:</strong></p>
<ul>
<li>Function simplicity</li>
<li>Granular control</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Significant complexity overhead</li>
<li>No support for nested tasks</li>
</ul>
<p><strong>Alternative Approaches:</strong></p>
<ul>
<li>Use a message broker instead of channels</li>
<li>Implement Redis pub/sub instead of channels</li>
<li>Add tasks to a hashmap first, then have the task system pull directly from the hashmap (though this would require multiple hashmaps for each type, adding complexity)</li>
<li>Use serialization to reduce reliance on generic types</li>
</ul>
<h3 id="cache-system">Cache System</h3>
<p>The Cache System follows a similar pattern to the Task System but uses Redis instead of PostgreSQL. I separated these systems because of a limitation: you cannot call a task within another task (or a channel within a channel) unless it comes from a different instance. The Cache System uses a separate channel instance, allowing cache operations to be called from within tasks.</p>
<h3 id="iam-identity-and-access-management">IAM (Identity And Access Management)</h3>
<p>The IAM implementation in this project is relatively straightforward. It doesn't include more complex features like effects, resources, or policies, focusing instead on user roles and permissions.</p>
<h3 id="permission-system">Permission System</h3>
<p>I designed the permission system for flexibility. Permissions are stored in PostgreSQL but cached differently than other data. Rather than using the Cache System to store them in Redis, they're cached locally in a HashMap. This approach was chosen based on scale considerations: while you might expect hundreds of permissions, you could have hundreds of thousands of users.</p>
<h4 id="caching">Caching</h4>
<p>The permission caching mechanism is straightforward but distinct from the main Cache System. If you want to use a local cache, you can bypass the Cache System and use <code>LocalizedCache&lt;T&gt;</code>, where T represents the type you want to cache (e.g., Permission). You would then implement <code>LocalizedCache&lt;Permission&gt;</code> for your <code>PermissionCache</code> type.</p>
<p>When calling <code>fn add(item: T)</code>, the system adds three keys: <code>permission_id</code>, <code>permission_name</code>, and <code>permission_key</code>. I chose to add these three keys because each field is unique in the database, allowing permissions to be retrieved by ID, name, or key.</p>
<p>All key values use an <code>Arc&lt;T&gt;</code> (where T is the same as in <code>LocalizedCache&lt;T&gt;</code>), creating a shared state. This means when you implement an <code>fn update()</code> and modify a field, it automatically updates the other two references.</p>
<h4 id="schema">Schema</h4>
<ul>
<li><strong>permission_id:</strong> UUID of the permission (randomly generated using the uuid crate)</li>
<li><strong>permission_name:</strong> Name of the permission. Example: "Ban User"</li>
<li><strong>permission_key:</strong> Key of the permission. Example: "admin.ban.user"</li>
</ul>
<p>The <code>permission_name</code> and <code>permission_key</code> can follow any format, though the examples above represent the ideal structure.</p>
<h4 id="relation">Relation</h4>
<p>Roles and permissions are interconnected. To maintain consistency, the role type includes a field <code>pub role_permissions: Vec&lt;String&gt;</code>, which contains only the IDs of associated permissions. This approach was chosen because the permission ID is the only immutable field within a permission.</p>
<h3 id="role-system">Role System</h3>
<p>I conceptualize roles as collections of grouped permissions. This allows for predefined permission sets that can be assigned to specific roles, eliminating the need to assign individual permissions (like "ban") to each user. Instead, users can be assigned a role with pre-configured permissions, ensuring consistency across the application.</p>
<h4 id="schema-1">Schema</h4>
<ul>
<li><strong>role_id:</strong> UUID of the role (randomly generated using the uuid crate)</li>
<li><strong>role_name:</strong> Name of the role. Example: "Moderator"</li>
</ul>
<p>The <code>role_name</code> and <code>role_id</code> can follow any format, though the examples represent the ideal naming convention.</p>
<h3 id="user-management">User Management</h3>
<p>Examining the <a href="https://github.com/notpointless/ark/blob/main/schema.sql">schema.sql</a> file and the <code>iam_users</code> table, you'll notice the absence of password fields. This is by design, as users authenticate exclusively through OAuth2 providers such as Google and Discord.</p>
<h4 id="security-features">Security Features</h4>
<p>The <code>iam_users</code> table includes <code>security_token</code> and <code>security_stamp</code> fields, inspired by ASP.NET Core's security model. When the <code>security_stamp</code> changes, the <code>security_token</code> is automatically invalidated. Let me break down how this currently works:</p>
<h5 id="security-stamp">security_stamp</h5>
<p>The <code>security_stamp</code> doesn't have a specific model but uses the <code>String</code> type. To generate a valid stamp, the function <code>fn generate_security_stamp(security_stamp: String, action: &amp;str)</code> is used. This function captures the current time in milliseconds, hashes it with SHA-256, and converts it to a hexadecimal string.</p>
<h5 id="security-token">security_token</h5>
<p>The model for <code>security_token</code> is:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug, Clone, PartialEq, Serialize, Deserialize)]
</span><span style="color:#65737e;">// security token for the user...
</span><span style="color:#b48ead;">pub struct </span><span>SecurityToken {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">token</span><span>: String,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">expiry</span><span>: </span><span style="color:#b48ead;">u128</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">action</span><span>: String,
</span><span>}
</span></code></pre>
<p>The token generation process:</p>
<ol>
<li>Call <code>SecurityToken::new(security_stamp: String, action: &amp;str)</code></li>
<li>Serialize the model with serde_json and convert to hexadecimal</li>
<li>Store the hexadecimal representation in the database</li>
</ol>
<p>To retrieve the token, call <code>decode_then_deserialize(security_token: Option&lt;String&gt;)</code>, which decodes the hexadecimal string, deserializes it to the <code>SecurityToken</code> type, and returns <code>None</code> if the token is empty.</p>
<h5 id="shorthand-usage">Shorthand Usage</h5>
<p>To generate a token with a specific action, use <code>UserSecurity::create(action)</code>. For example, to create an email reset token:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>UserSecurity::create(&quot;</span><span style="color:#a3be8c;">email_reset</span><span>&quot;);
</span></code></pre>
<p>Then, in your route handler for <code>/auth/email_reset</code>, check if the <code>SecurityToken</code> exists and verify that the action is set to "email_reset". If not, deny access.</p>
<hr />
<p>This completes the technical overview of the current state of the Ark project. I welcome feedback and contributions to further improve its architecture and functionality.</p>
 </main>
  </body>
</html>
